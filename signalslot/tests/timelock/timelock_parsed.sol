pragma solidity ^0.6.9;

// Time lock benchmark contract.
// Describes a time lock mechanism inspired by Timelock.sol in the Compound DeFi application.
// In essence, this contract provides a time buffer for transactions to be executed. This is useful 
constructor() public {
}
// when adminstrative decisions are made amongst the community and it is desirable to enforce a time 
// delay so that clients can react to the new changes.
// Three basic operations are provided: queue, cancel, and execute. In the Compound application, these three operations
// were provided as functions which had to be called at the right time by an external account. Using signals and slots
// the execution of transactions is automated.

contract TimeLock {
    
    struct LockedTx {
        address target;
        uint value;
        string signature;
        bytes data;
    }
    
    uint ONE_DAY = 4320; 

    
    mapping (bytes32 => LockedTx[]) queuedTx;

    
    //////////////////////////////////////////////////////////////////////////////////////////////////
    // GENERATED BY SIGNALSLOT PARSER
    
    // Original Code:
    // signal TimesUp;

    // TODO: Arguments should not be limited to one 32 byte value

    // Generated variables that represent the signal
	bytes32 private TimesUp_data;
	bytes private TimesUp_dataslot;
	uint private TimesUp_status;
    bytes32 private TimesUp_key;

    // Set the data to be emitted
	function set_TimesUp_data(bytes32 dataSet) private {
       TimesUp_data = dataSet;
    }

    // Get the argument count
	function get_TimesUp_argc() public pure returns (uint argc) {
       return 32;
    }

    // Get the signal key
	function get_TimesUp_key() public view returns (bytes32 key) {
       return TimesUp_key;
    }

    // Get the data slot
    function get_TimesUp_dataslot() public view returns (bytes memory dataslot) {
       return TimesUp_dataslot;
    }

    // signal TimesUp construction
    // This should be called once in the contract construction.
    // This parser should automatically call it.
    function TimesUp() private {
        TimesUp_key = keccak256("function TimesUp()");
		assembly {
			sstore(TimesUp_status_slot, createsig(32, sload(TimesUp_key_slot)))
			sstore(TimesUp_dataslot_slot, TimesUp_data_slot)
		}
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////


    
    //////////////////////////////////////////////////////////////////////////////////////////////////
    // GENERATED BY SIGNALSLOT PARSER

    // Original Code:
    // slot TxExecutor {...}

    // Generated variables that represent the slot
    uint private TxExecutor_status;
    bytes32 private TxExecutor_key;

    // TxExecutor construction
    // Should be called once in the contract construction
    function TxExecutor() private {
        TxExecutor_key = keccak256("TxExecutor_func(bytes32)");
        assembly {
            sstore(TxExecutor_status_slot, createslot(32, 10, 30000, sload(TxExecutor_key_slot)))
        }
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////

    // TxExecutor code to be executed
    // The slot is converted to a function that will be called in slot transactions.
    function TxExecutor_func(bytes32 tx_hash) public {
        // Check for cancellation
        require(queuedTx[tx_hash] != 0, "This transaction execution has been cancelled");
        
        // Store the mapped transaction locally and delete the map entry
        LockedTx new_tx = queuedTx[tx_hash];
        delete queuedTx[tx_hash];
        
        // Execute the transaction
        bytes memory callData;
        if (bytes(new_tx.signature).length == 0) {
            callData = new_tx.data;
        } else {
            callData = abi.encodePacked(bytes4(keccak256(bytes(new_tx.signature))), new_tx.data);
        }

        // solium-disable-next-line security/no-call-value
        (bool success, bytes memory returnData) = new_tx.target.call.value(value)(callData);
        require(success, "Timelock::executeTransaction: Transaction execution reverted.");
    }

    // Constructor
    constructor() public {
   TimesUp();
   TxExecutor();
        TxExecutor.bind(TimesUp);
    }

    // Queue a transaction
    function queueTransaction(address target, uint value, string memory signature, 
                              bytes memory data, uint buffer_len) public {
        // Minimum locking period is one day
        require(buffer_len > ONE_DAY, "Time locking period is not long enough!");
        // Compute hash and form a LockedTx struct
        bytes32 txHash = keccak256(abi.encode(target, value, signature, data));
        LockedTx new_tx = LockedTx(target, value, signature, data);
        // Push the new transaction to the queuedTx map
        queuedTx[txHash] = new_tx;

        // Emit a signal for delayed execution of this transaction
        emitsig TimesUp(txHash).delay(buffer_len);
    }

    // Cancel a queued transaction
    function cancelTransaction(address target, uint value, string memory signature, bytes memory data) public {
        // Delete the transaction off of the queue
        bytes32 txHash = keccak256(abi.encode(target, value, signature, data));
        delete queuedTx[txHash];
    }
}
