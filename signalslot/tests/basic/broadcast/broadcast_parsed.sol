pragma solidity ^0.6.9;


contract Emitter {
    //////////////////////////////////////////////////////////////////////////////////////////////////
    // GENERATED BY SIGNALSLOT PARSER

    // Original code:
    // signal Alert

    // Generated variables that represent the signal
	bytes32 private Alert_dataslot;//the data pointer is NULL
	uint private Alert_status;
    bytes32 private Alert_key;

    // Get the signal key
	function get_Alert_key() public view returns (bytes32 key) {
       return Alert_key;
    }

    // Get the data slot
    function get_Alert_dataslot() private view returns (bytes32 dataslot) {
       return Alert_dataslot;
    }

    // signal Alert construction
    // This should be called once in the contract construction.
    // This parser should automatically call it.
    function Alert() private {
        Alert_key = keccak256("Alert()");
		assembly {
			sstore(Alert_status_slot, createsig(0, sload(Alert_key_slot)))
			sstore(Alert_dataslot_slot, 0x0)
		}
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////

    function send_alert() public view {
        //////////////////////////////////////////////////////////////////////////////////////////////////
        // GENERATED BY SIGNALSLOT PARSER

        // Original Code:
        // emitsig Alert().delay(0)

        // Get the data slot
		bytes32 this_emitsig_Alert_dataslot = get_Alert_dataslot();
        // Get the signal key
		bytes32 this_emitsig_Alert_key = get_Alert_key();
        // Use assembly to emit the signal and queue up slot transactions
		assembly {
			mstore(0x40, emitsig(this_emitsig_Alert_key, 0, this_emitsig_Alert_dataslot, 0))
	    }
        //////////////////////////////////////////////////////////////////////////////////////////////////

    }
constructor() public {
   Alert();
}
}

contract ReceiverA {
    bytes32 private data;
    //////////////////////////////////////////////////////////////////////////////////////////////////
    // GENERATED BY SIGNALSLOT PARSER

    // Original Code:
    // slot HandleAlert {...}

    // Generated variables that represent the slot
    uint private HandleAlert_status;
    bytes32 private HandleAlert_key;

    // Get the signal key
	function get_HandleAlert_key() public view returns (bytes32 key) {
       return HandleAlert_key;
    }

    // HandleAlert construction
    // Should be called once in the contract construction
    function HandleAlert() private {
        HandleAlert_key = keccak256("HandleAlert_func()");
        assembly {
            sstore(HandleAlert_status_slot, createslot(0, 10, 30000, sload(HandleAlert_key_slot)))
        }
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////

    // HandleAlert code to be executed
    // The slot is converted to a function that will be called in slot transactions.
    function HandleAlert_func() public {
        data = 0;
    }
    function bind_to_alert(Emitter addr) public view {
        //////////////////////////////////////////////////////////////////////////////////////////////////
        // GENERATED BY SIGNALSLOT PARSER

        // Original Code:
        // HandleAlert.bind(addr.Alert)

        // Convert to address
		address addr_bindslot_address = address(addr);
        // Get signal key from emitter contract
		bytes32 addr_bindslot_Alert_key = keccak256("Alert()");
        // Get slot key from receiver contract
        bytes32 this_addr_bindslot_HandleAlert_key = get_HandleAlert_key();
        // Use assembly to bind slot to signal
		assembly {
			mstore(0x40, bindslot(addr_bindslot_address, addr_bindslot_Alert_key, this_addr_bindslot_HandleAlert_key))
	    }
        //////////////////////////////////////////////////////////////////////////////////////////////////

    }
constructor() public {
   HandleAlert();
}
}

contract ReceiverB {
    bytes32 private data;
    //////////////////////////////////////////////////////////////////////////////////////////////////
    // GENERATED BY SIGNALSLOT PARSER

    // Original Code:
    // slot HandleAlert {...}

    // Generated variables that represent the slot
    uint private HandleAlert_status;
    bytes32 private HandleAlert_key;

    // Get the signal key
	function get_HandleAlert_key() public view returns (bytes32 key) {
       return HandleAlert_key;
    }

    // HandleAlert construction
    // Should be called once in the contract construction
    function HandleAlert() private {
        HandleAlert_key = keccak256("HandleAlert_func()");
        assembly {
            sstore(HandleAlert_status_slot, createslot(0, 10, 30000, sload(HandleAlert_key_slot)))
        }
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////

    // HandleAlert code to be executed
    // The slot is converted to a function that will be called in slot transactions.
    function HandleAlert_func() public {
        data = 0;
    }
    function bind_to_alert(Emitter addr) public view {
        //////////////////////////////////////////////////////////////////////////////////////////////////
        // GENERATED BY SIGNALSLOT PARSER

        // Original Code:
        // HandleAlert.bind(addr.Alert)

        // Convert to address
		address addr_bindslot_address = address(addr);
        // Get signal key from emitter contract
		bytes32 addr_bindslot_Alert_key = keccak256("Alert()");
        // Get slot key from receiver contract
        bytes32 this_addr_bindslot_HandleAlert_key = get_HandleAlert_key();
        // Use assembly to bind slot to signal
		assembly {
			mstore(0x40, bindslot(addr_bindslot_address, addr_bindslot_Alert_key, this_addr_bindslot_HandleAlert_key))
	    }
        //////////////////////////////////////////////////////////////////////////////////////////////////

    }
constructor() public {
   HandleAlert();
}
}