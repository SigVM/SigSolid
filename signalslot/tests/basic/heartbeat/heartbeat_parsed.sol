pragma solidity ^0.6.9;

// Simple heartbeat 'contract' utilizing delayed 'signal' emit

contract HeartBeat {
    uint32 counter;

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // GENERATED BY SIGNALSLOT PARSER

    // Original code:
    // signal Heart

    // Generated variables that represent the signal
	bytes private Heart_dataslot;//the data pointer is NULL
	uint private Heart_status;
    bytes32 private Heart_key;

    // Get the signal key
	function get_Heart_key() public view returns (bytes32 key) {
       return Heart_key;
    }

    // Get the data slot
    function get_Heart_dataslot() private view returns (bytes memory dataslot) {
       return Heart_dataslot;
    }

    // signal Heart construction
    // This should be called once in the contract construction.
    // This parser should automatically call it.
    function Heart() private {
        Heart_key = keccak256("function Heart()");
		assembly {
			sstore(Heart_status_slot, createsig(0, sload(Heart_key_slot)))
			sstore(Heart_dataslot_slot, 0x0)
		}
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // GENERATED BY SIGNALSLOT PARSER

    // Original Code:
    // slot Beat {...}

    // Generated variables that represent the slot
    uint private Beat_status;
    bytes32 private Beat_key;

    // Beat construction
    // Should be called once in the contract construction
    function Beat() private {
        Beat_key = keccak256("Beat_func()");
        assembly {
            sstore(Beat_status_slot, createslot(0, 10, 30000, sload(Beat_key_slot)))
        }
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////

    // Beat code to be executed
    // The slot is converted to a function that will be called in slot transactions.
    function Beat_func() public {
        counter = counter + 1;
        emitsig Heart().delay(10);
    }

    constructor() public {
   Heart();
   Beat();
        counter = 0;
        //////////////////////////////////////////////////////////////////////////////////////////////////
        // GENERATED BY SIGNALSLOT PARSER

        // Original Code:
        // Beat.bind(this.Heart)

        // Convert to address
		address this_address = address(this);
        // Get signal key from emitter contract
		bytes32 this_Heart_key = this.get_Heart_key();
        // Use assembly to bind slot to signal
		assembly {
			mstore(0x40, bindslot(this_address, this_Heart_key, sload(Beat_key_slot)))
	    }
        //////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////
        // GENERATED BY SIGNALSLOT PARSER

        // Original Code:
        // emitsig Heart().delay(10)

        // Get the data slot
		bytes memory this_Heart_dataslot = this.get_Heart_dataslot();
        // Get the signal key
		bytes32 this_Heart_key = this.get_Heart_key();
        // Use assembly to emit the signal and queue up slot transactions
		assembly {
			mstore(0x40, emitsig(this_Heart_key, 10, this_Heart_dataslot, 0))
	    }
        //////////////////////////////////////////////////////////////////////////////////////////////////

    }
}