pragma solidity ^0.6.9;
contract EmitOnTime {
    //////////////////////////////////////////////////////////////////////////////////////////////////
    // GENERATED BY SIGNALSLOT PARSER
    
    // Original Code:
    // signal Alert;

    // TODO: Arguments should not be limited to one 32 byte value

    // Generated variables that represent the signal
	bytes32 private Alert_data;
	bytes32 private Alert_dataslot;
	uint private Alert_status;
    bytes32 private Alert_key;

    // Set the data to be emitted
	function set_Alert_data(bytes32 dataSet) private {
       Alert_data = dataSet;
    }

    // Get the argument count
	function get_Alert_argc() public pure returns (uint argc) {
       return 32;
    }

    // Get the signal key
	function get_Alert_key() public view returns (bytes32 key) {
       return Alert_key;
    }

    // Get the data slot
    function get_Alert_dataslot() public view returns (bytes32 dataslot) {
       return Alert_dataslot;
    }

    // signal Alert construction
    // This should be called once in the contract construction.
    // This parser should automatically call it.
    function Alert() private {
        Alert_key = keccak256("Alert()");
		assembly {
			sstore(Alert_status_slot, createsig(32, sload(Alert_key_slot)))
			sstore(Alert_dataslot_slot, Alert_data_slot)
		}
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////


    function send_alert(bytes32 data) public {
        //////////////////////////////////////////////////////////////////////////////////////////////////
        // GENERATED BY SIGNALSLOT PARSER
        
        // Original Code:
        // emitsig Alert(data).delay(0)

        // Set the data field in the signal
        set_Alert_data(data);
        // Get the argument count
        uint this_emitsig_Alert_argc = get_Alert_argc();
        // Get the data slot
		bytes32 this_emitsig_Alert_dataslot = get_Alert_dataslot();
        // Get the signal key
		bytes32 this_emitsig_Alert_key = get_Alert_key();
        // Use assembly to emit the signal and queue up slot transactions
		assembly {
			mstore(0x40, emitsig(this_emitsig_Alert_key, 0, this_emitsig_Alert_dataslot, this_emitsig_Alert_argc))
	    }
        //////////////////////////////////////////////////////////////////////////////////////////////////

    }
constructor() public {
   Alert();
}
}
contract EmitLate {
    //////////////////////////////////////////////////////////////////////////////////////////////////
    // GENERATED BY SIGNALSLOT PARSER
    
    // Original Code:
    // signal Alert;

    // TODO: Arguments should not be limited to one 32 byte value

    // Generated variables that represent the signal
	bytes32 private Alert_data;
	bytes32 private Alert_dataslot;
	uint private Alert_status;
    bytes32 private Alert_key;

    // Set the data to be emitted
	function set_Alert_data(bytes32 dataSet) private {
       Alert_data = dataSet;
    }

    // Get the argument count
	function get_Alert_argc() public pure returns (uint argc) {
       return 32;
    }

    // Get the signal key
	function get_Alert_key() public view returns (bytes32 key) {
       return Alert_key;
    }

    // Get the data slot
    function get_Alert_dataslot() public view returns (bytes32 dataslot) {
       return Alert_dataslot;
    }

    // signal Alert construction
    // This should be called once in the contract construction.
    // This parser should automatically call it.
    function Alert() private {
        Alert_key = keccak256("Alert()");
		assembly {
			sstore(Alert_status_slot, createsig(32, sload(Alert_key_slot)))
			sstore(Alert_dataslot_slot, Alert_data_slot)
		}
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////


    function send_alert(bytes32 data) public {
        //////////////////////////////////////////////////////////////////////////////////////////////////
        // GENERATED BY SIGNALSLOT PARSER
        
        // Original Code:
        // emitsig Alert(data).delay(10)

        // Set the data field in the signal
        set_Alert_data(data);
        // Get the argument count
        uint this_emitsig_Alert_argc = get_Alert_argc();
        // Get the data slot
		bytes32 this_emitsig_Alert_dataslot = get_Alert_dataslot();
        // Get the signal key
		bytes32 this_emitsig_Alert_key = get_Alert_key();
        // Use assembly to emit the signal and queue up slot transactions
		assembly {
			mstore(0x40, emitsig(this_emitsig_Alert_key, 10, this_emitsig_Alert_dataslot, this_emitsig_Alert_argc))
	    }
        //////////////////////////////////////////////////////////////////////////////////////////////////

    }
constructor() public {
   Alert();
}
}
contract Receiver {
    bytes32 data;
    uint32 alert_count;

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // GENERATED BY SIGNALSLOT PARSER

    // Original Code:
    // slot Receive {...}

    // Generated variables that represent the slot
    uint private Receive_status;
    bytes32 private Receive_key;

    // Get the signal key
	function get_Receive_key() public view returns (bytes32 key) {
       return Receive_key;
    }

    // Receive construction
    // Should be called once in the contract construction
    function Receive() private {
        Receive_key = keccak256("Receive_func(bytes32)");
        assembly {
            sstore(Receive_status_slot, createslot(32, 10, 30000, sload(Receive_key_slot)))
        }
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////

    // Receive code to be executed
    // The slot is converted to a function that will be called in slot transactions.
    function Receive_func(bytes32 incoming_data) public {
        data = incoming_data;
        alert_count = alert_count + 1;
    }
    function get_data() public view returns (bytes32 ret) {
        ret = data;
    }
    function get_alert_count() public view returns (uint32 ret) {
        ret = alert_count;
    }
    function bind_to_signal(address emitter) public view {
        //////////////////////////////////////////////////////////////////////////////////////////////////
        // GENERATED BY SIGNALSLOT PARSER

        // Original Code:
        // Receive.bind(emitter.Alert)

        // Convert to address
		address emitter_bindslot_address = address(emitter);
        // Get signal key from emitter contract
		bytes32 emitter_bindslot_Alert_key = keccak256("Alert()");
        // Get slot key from receiver contract
        bytes32 this_emitter_bindslot_Receive_key = get_Receive_key();
        // Use assembly to bind slot to signal
		assembly {
			mstore(0x40, bindslot(emitter_bindslot_address, emitter_bindslot_Alert_key, this_emitter_bindslot_Receive_key))
	    }
        //////////////////////////////////////////////////////////////////////////////////////////////////

    }
    constructor() public {
        Receive();
        data = 0;
        alert_count = 0;
    }
}