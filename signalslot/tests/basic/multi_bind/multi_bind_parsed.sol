pragma solidity ^0.6.9;


contract EmitOnTime {
    bytes32 private data;
    //////////////////////////////////////////////////////////////////////////////////////////////////
    // GENERATED BY SIGNALSLOT PARSER
    
    // Original Code:
    // signal Alert;

    // TODO: Arguments should not be limited to one 32 byte value

    // Generated variables that represent the signal
	bytes32 private Alert_data;
	bytes private Alert_dataslot;
	uint private Alert_status;
    bytes32 private Alert_key;

    // Set the data to be emitted
	function set_Alert_data(bytes32 dataSet) private {
       Alert_data = dataSet;
    }

    // Get the argument count
	function get_Alert_argc() public pure returns (uint argc) {
       return 32;
    }

    // Get the signal key
	function get_Alert_key() public view returns (bytes32 key) {
       return Alert_key;
    }

    // Get the data slot
    function get_Alert_dataslot() public view returns (bytes memory dataslot) {
       return Alert_dataslot;
    }

    // signal Alert construction
    // This should be called once in the contract construction.
    // This parser should automatically call it.
    function Alert() private {
        Alert_key = keccak256("function Alert()");
		assembly {
			sstore(Alert_status_slot, createsig(32, sload(Alert_key_slot)))
			sstore(Alert_dataslot_slot, Alert_data_slot)
		}
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////


    function send_alert(bytes32 value) public {
        data = data | value;
        //////////////////////////////////////////////////////////////////////////////////////////////////
        // GENERATED BY SIGNALSLOT PARSER
        
        // Original Code:
        // emitsig Alert(data).delay(0)

        // Set the data field in the signal
        set_Alert_data(data);
        // Get the argument count
        uint this_emitsig_Alert_argc = get_Alert_argc();
        // Get the data slot
		bytes memory this_emitsig_Alert_dataslot = get_Alert_dataslot();
        // Get the signal key
		bytes32 this_emitsig_Alert_key = get_Alert_key();
        // Use assembly to emit the signal and queue up slot transactions
		assembly {
			mstore(0x40, emitsig(this_emitsig_Alert_key, 0, this_emitsig_Alert_dataslot, this_emitsig_Alert_argc))
	    }
        //////////////////////////////////////////////////////////////////////////////////////////////////

    }

    function clear_data() public {
        data = 0;
    }

    constructor() public {
   Alert();
        data = 0;
    }
}

contract EmitLate {
    bytes32 private data;
    //////////////////////////////////////////////////////////////////////////////////////////////////
    // GENERATED BY SIGNALSLOT PARSER
    
    // Original Code:
    // signal Alert;

    // TODO: Arguments should not be limited to one 32 byte value

    // Generated variables that represent the signal
	bytes32 private Alert_data;
	bytes private Alert_dataslot;
	uint private Alert_status;
    bytes32 private Alert_key;

    // Set the data to be emitted
	function set_Alert_data(bytes32 dataSet) private {
       Alert_data = dataSet;
    }

    // Get the argument count
	function get_Alert_argc() public pure returns (uint argc) {
       return 32;
    }

    // Get the signal key
	function get_Alert_key() public view returns (bytes32 key) {
       return Alert_key;
    }

    // Get the data slot
    function get_Alert_dataslot() public view returns (bytes memory dataslot) {
       return Alert_dataslot;
    }

    // signal Alert construction
    // This should be called once in the contract construction.
    // This parser should automatically call it.
    function Alert() private {
        Alert_key = keccak256("function Alert()");
		assembly {
			sstore(Alert_status_slot, createsig(32, sload(Alert_key_slot)))
			sstore(Alert_dataslot_slot, Alert_data_slot)
		}
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////


    function send_alert(bytes32 value) public {
        data = data | value;
        //////////////////////////////////////////////////////////////////////////////////////////////////
        // GENERATED BY SIGNALSLOT PARSER
        
        // Original Code:
        // emitsig Alert(data).delay(10)

        // Set the data field in the signal
        set_Alert_data(data);
        // Get the argument count
        uint this_emitsig_Alert_argc = get_Alert_argc();
        // Get the data slot
		bytes memory this_emitsig_Alert_dataslot = get_Alert_dataslot();
        // Get the signal key
		bytes32 this_emitsig_Alert_key = get_Alert_key();
        // Use assembly to emit the signal and queue up slot transactions
		assembly {
			mstore(0x40, emitsig(this_emitsig_Alert_key, 10, this_emitsig_Alert_dataslot, this_emitsig_Alert_argc))
	    }
        //////////////////////////////////////////////////////////////////////////////////////////////////

    }

    function clear_data() public {
        data = 0;
    }

    constructor() public {
   Alert();
        data = 0;
    }
}

contract Receiver {
    EmitOnTime public on_time;
    EmitLate public late;

    
    uint32 private alert_count;

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // GENERATED BY SIGNALSLOT PARSER

    // Original Code:
    // slot Receive {...}

    // Generated variables that represent the slot
    uint private Receive_status;
    bytes32 private Receive_key;

    // Get the signal key
	function get_Receive_key() public view returns (bytes32 key) {
       return Receive_key;
    }

    // Receive construction
    // Should be called once in the contract construction
    function Receive() private {
        Receive_key = keccak256("Receive_func(bytes32)");
        assembly {
            sstore(Receive_status_slot, createslot(32, 10, 30000, sload(Receive_key_slot)))
        }
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////

    // Receive code to be executed
    // The slot is converted to a function that will be called in slot transactions.
    function Receive_func(bytes32 data) public {
        alert_count = 0;
        for(uint i = 0; i < 32; i++) {
            if(!(data[0] == 0x00)) {
                alert_count = alert_count + 1;
            }
            data = data >> 1;
        }
    }

    function get_alert_count() public view returns (uint32 ret) {
        ret = alert_count;
    }

    constructor(EmitOnTime first, EmitLate second) public {
   Receive();
        on_time = first;
        late = second;
        //////////////////////////////////////////////////////////////////////////////////////////////////
        // GENERATED BY SIGNALSLOT PARSER

        // Original Code:
        // Receive.bind(on_time.Alert)

        // Convert to address
		address on_time_bindslot_address = address(on_time);
        // Get signal key from emitter contract
		bytes32 on_time_bindslot_Alert_key = on_time.get_Alert_key();
        // Get slot key from receiver contract
        bytes32 this_bindslot_Receive_key = get_Receive_key();
        // Use assembly to bind slot to signal
		assembly {
			mstore(0x40, bindslot(on_time_bindslot_address, on_time_bindslot_Alert_key, this_bindslot_Receive_key))
	    }
        //////////////////////////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////////////////////////
        // GENERATED BY SIGNALSLOT PARSER

        // Original Code:
        // Receive.bind(late.Alert)

        // Convert to address
		address late_bindslot_address = address(late);
        // Get signal key from emitter contract
		bytes32 late_bindslot_Alert_key = late.get_Alert_key();
        // Get slot key from receiver contract
        bytes32 this_bindslot_Receive_key = get_Receive_key();
        // Use assembly to bind slot to signal
		assembly {
			mstore(0x40, bindslot(late_bindslot_address, late_bindslot_Alert_key, this_bindslot_Receive_key))
	    }
        //////////////////////////////////////////////////////////////////////////////////////////////////

    }
}